#' Nuclear FRAP Data Analysis Package 
#'
#' This package prvides functions to load, visualize and do model fitting on FRAP data. 
#' It also provides functions to do profile likelihood analysis. 
#'
#' To install NuclearFRAP read  
#' \code{vignette("Install")}
#'
#' To get started with NuclearFRAP chek out the introduction 
#' \code{vignette("NuclearFRAP")}
#'
#' To see the model defintion and parameters
#' \code{vignette("Model")}
#'
#' To see a tutorial on image acquisition and manual analysis (in spanish)
#' \code{vignette("Tutorial")}
#'
#' @name NuclearFRAP
#' @docType package
#' @author Alan Bush \email{abush@@fbmc.fcen.uba.ar}
NULL

#' List of options for the FRAP experiment analysis
#'
#' @name FRAP.options
#' @details this list contains all the options that have to be defined for the analysis 
#' \tabular{ll}{
#'			\code{MODEL.PARAMETERS} \tab character vector with the model's parameter names, in the order expected by the matlab functions \cr
#'			\code{FIXED.PARAMETERS} \tab named integer vector, with a 1 for fixed parameters and a 0 for free parameters. Same order as MODEL.PARAMETERS\cr
#'			\code{VALUE.PARAMETERS} \tab named numeric vector, with initial or fixed values for the parameters. If 'NA', the parameter is estimated from the data by \code{\link{calcInitBound}}.\cr
#'			\code{PRE.ACTIVATION.FRAMES} \tab number of frames before the photo bleaching \cr
#'			\code{TOTAL.FRAMES.PER.FRAP} \tab total number of frames in a FRAP, this includes the pre activation frames \cr
#'			\code{AUTO.F} \tab fix autofluorescence to substract to the signal. Normally zero as the auto fluorescence is a parameter of the model.\cr
#'			\code{F.COR.CYT} \tab cytoplasmatic correction factor. A fix number by which to multiply the cytoplasmic fluorescence to compensate differences in volumen between the nucleous 
#'							 and cytoplasm. Normally fixed at one since the model's parameter geomVfrac takes care of this.\cr
#'			\code{SEC.PER.FRAME} \tab seconds per frame, used to calculate the time of each frame. This can change between experiments\cr
#'			\code{PB.CORRECTION.FUN} \tab a function, with arguments fl (fluorescence) and time. Returns the value of fluorescence corrected by imaging photobleaching. 
#'									 If photobleaching is neglectable, can be set to the 'identity' function.\cr
#'			\code{SIGMA.FUN} \tab a function of the fluorescnece level that returns the sigma, i.e. the expected noise level for each fluorescence level. Only used if SIGMA.METHOD='SIGMA.FUN'\cr
#'			\code{SIGMA.METHOD} \tab string indicating wich method to use to estimate the noise (sigma). Available options are 'SIGMA.FUN' and 'SINGLE.CELL.PAIR'. 
#'								See \code{\link{getCrossResidualsPair}} for more details on this last method.\cr
#'			\code{FRAP.ORDER.SEP} \tab separator string for the 'pb' column of the description file specified by 'desc' (see below)\cr
#'			\code{FRAP.ORDER.DAUGHTER.STR} \tab daughter token for the pb column of the description file\cr
#'			\code{FRAP.ORDER.MOTHER.STR} \tab mother token for the pb column of the description file\cr
#'			\code{MOTHER.FRAP.NUMBER} \tab number of FRAPs in the train of FRAPs expected for the mother\cr
#'			\code{DAUGHTER.FRAP.NUMBER} \tab number of FRAPs in the train of FRAPs expected for the daughter\cr
#'			\code{TOT0.SIGMA.FACTOR} \tab number of standard deviations to let the 'tot0' parameter wonder about during the fit. 
#'									This region is centered in the initial estimation for 'tot0' done by \code{\link{calcInitBound}}\cr
#'			\code{ref.img} \tab string with pattern for the reference images. That is the images with the nuclear and citoplasmic regions drawn on it.\cr
#'			\code{time.series} \tab string with pattern for the time-series files. Those are the files generated by ImageJ's plugin 'Time Series Analyzer v2'\cr
#'			\code{fname} \tab string with pattern for the text file containing the file-names of all the tif images in the experiment.\cr
#'			\code{desc} \tab string with pattern for the description file of the experiment. This tab delimited file should contain the columns 'pos' (or 'lev'), 'pb' and other description columns\cr
#'			\code{OIF.date} \tab string with the name of the OIF-date file, i.e. the file with all acuisition dates of the images\cr
#'			\code{channel.name} \tab string with name of the relevant channel\cr
#' }
#' @export
param.FRAP.pairs <- list(VERSION.STR="51"
	,MODEL.PARAMETERS=c("log10_kEVfrac","log10_kI","tot0","Fn0","Fc0","PBn","PBfrac","log2_geomVfrac","auto0n","auto0frac","an1","an2","ac0","ac1","ac2","log2_geomVfrac_mean","log2_geomVfrac_sd")
	,FIXED.PARAMETERS=c(log10_kEVfrac=0,log10_kI=0,tot0=0,Fn0=0,Fc0=0,PBn=0,PBfrac=0,log2_geomVfrac=0,auto0n=0,auto0frac=1,an1=0,an2=0,ac0=1,ac1=1,ac2=1,log2_geomVfrac_mean=1,log2_geomVfrac_sd=1)
	,VALUE.PARAMETERS=c(log10_kEVfrac=NA,log10_kI=NA,tot0=NA,Fn0=0,Fc0=0,PBn=NA,PBfrac=0,log2_geomVfrac=4,auto0n=0,auto0frac=1,an1=0,an2=0,ac0=1,ac1=0,ac2=0,log2_geomVfrac_mean=3.1,log2_geomVfrac_sd=0.434)
	,LOWER.PARAMETERS=c(log10_kEVfrac=NA,log10_kI=NA,tot0=NA,Fn0=0,Fc0=0,PBn=0,PBfrac=0,log2_geomVfrac=0,auto0n=0,auto0frac=0.1,an1=-0.1,an2=-0.001,ac0=0.5,ac1=-0.1,ac2=-0.001,log2_geomVfrac_mean=-3,log2_geomVfrac_sd=NA)
	,UPPER.PARAMETERS=c(log10_kEVfrac=NA,log10_kI=NA,tot0=NA,Fn0=1e4,Fc0=1e4,PBn=1,PBfrac=1,log2_geomVfrac=8,auto0n=1e4,auto0frac=10,an1=0.1,an2=0.001,ac0=1.5,ac1=0.1,ac2=0.001,log2_geomVfrac_mean=6,log2_geomVfrac_sd=NA)
	,PRE.ACTIVATION.FRAMES=5 
	,TOTAL.FRAMES.PER.FRAP=35 
	,AUTO.F=0 
	,F.COR.CYT=1 
	,SEC.PER.FRAME=0.22 #time between consecutive frames
	,PB.CORRECTION.FUN=function(fl,time) fl 
	,SIGMA.FUN=function(fl) fl
	,SIGMA.METHOD="SINGLE.CELL.PAIR"
	#,SIGMA.METHOD="SIGMA.FUN"
	#,SIGMA.METHOD="FROM.DATA"
	,FRAP.ORDER.SEP="-"
	,FRAP.ORDER.DAUGHTER.STR="hija"
	,FRAP.ORDER.MOTHER.STR="madre"
	,MOTHER.FRAP.NUMBER=4
	,DAUGHTER.FRAP.NUMBER=4
	,TOT0.SIGMA.FACTOR=3
	,GEOMVFRAC.SIGMA.FACTOR=3
	,GEOMVFRAC.REL.SD=0.2

	#parameters used to load the experiment
	,ref.img="lev*.stk.jpg"
	,time.series="lev*-time-*.xls"
	,fname="lev*-tif-fname.txt"
	,desc="levData.txt"
	,OIF.date="OIF-date.txt"
	,channel.name="YFP"
)

#' makes a image montage of a cell pair with the available images
#'
#' @param X a cell.data object (as returned by \code{load.FRAP.pairs} to restructure
#' @param pos number of position of interest. Numeric vector of length one. 
#' @param timeBlock number of consecutive frames to average in shown images
#' @param box.size size in pixels of the image containing the cells. This specifies the 'radius', i.e. the image will be a square of length 2*box.size+1
#' @param ... further arguments for \code{\link{cimage}}
#' @return The function returns an invisible 'Image' object of the EBImage package. 
#' @export
imageCellPair<-function(X,pos,timeBlock=X$parameters$PRE.ACTIVATION.FRAMES,box.size=128/2-1,...){
	if(length(pos)>1) stop("single pos required")
	if(!pos%in%unique(X$data$pos)) stop("pos not in cell.data X")
	if(!"FRAP.on" %in% names(X$data)) X <- transform(X,FRAP.on=factor("cell")) #single cells, not pairs

	ch.db <- aggregateBy(X$images[X$images$pos==pos,c("channel","path")],.(channel),FUN=function(x) all(!is.na(x)))
	channel <- ch.db[ch.db$path,"channel"]
	X$data<-transform(X$data,t.indexBlock=(t.index-1)%/%timeBlock+1)
	X$data$iPos <- pos
	X$variables$all<-c(X$variables$all,"t.indexBlock")

	if(length(channel)==2){ #both ref and images
		if(!"ref"%in%channel) stop("two channels found, but 'ref' is not one of them")
		ci <- get.cell.image(X,subset=pos==iPos,channel.subset=channel==setdiff(channel,"ref")|channel=="ref"&t.index==1
					,N=1,contained.box=TRUE,box.size=box.size,time.course=T
					,select=c("t.indexBlock","FRAP","FRAP.on","pos"))
		ci<-ciciply(ci,c("channel","FRAP","t.indexBlock"),FUN=sum,MARGIN=c(1,2))
		ci<-cnormalize(ci,normalize.group=c("channel","FRAP"))
		rcell2:::img.desc(ci)<-transform(rcell2:::img.desc(ci),FRAP=revFactor(factor(FRAP)))
		return(cimage(ci, FRAP + FRAP.on ~ channel + t.indexBlock,facets=~pos,...))
	} else if(length(channel)==1) {
		if(channel=="ref"){ #only ref		
			ci<-get.cell.image(d,subset=pos==iPos & t.index==1,channel=="ref"
								,N=1,contained.box=TRUE,box.size=box.size,time.course=T
								,select=c("FRAP","FRAP.on","pos"))
			ci<-cnormalize(ci,normalize.group=c("channel","FRAP"))
			rcell2:::img.desc(ci)<-transform(rcell2:::img.desc(ci),FRAP=revFactor(factor(FRAP)))
			return(cimage(ci, channel ~ FRAP.on ,facets=~pos,...))
		}else{ #only images
			ci <- get.cell.image(X,subset=pos==iPos,channel=channel
						,N=1,contained.box=TRUE,box.size=box.size,time.course=T
						,select=c("t.indexBlock","FRAP","FRAP.on","pos"))
			ci<-ciciply(ci,c("channel","FRAP","t.indexBlock"),FUN=sum,MARGIN=c(1,2))
			ci<-cnormalize(ci,normalize.group=c("channel","FRAP"))
			rcell2:::img.desc(ci)<-transform(rcell2:::img.desc(ci),FRAP=revFactor(factor(FRAP)))
			return(cimage(ci, FRAP + FRAP.on ~ channel + t.indexBlock,facets=~pos,...))			
		}
	} else {
		return(NULL)
	}
}

#' makes a image montage of a single cell with the available images
#'
#' @inheritParams imageCellPair
#' @return The function returns an invisible 'Image' object of the EBImage package. 
#' @export
imageCell <- imageCellPair


#' Decouple a data.frame 
#' 
#' @details Restructures a data.frame, transforming '*_mother' and '*_daughter' variables to the appropiate position 
#'			to be compatible with \code{decouplePairs}.
#' @param db a data.frame to be restructured. It should have a pos varibale and '*_mother' and '*_daughter' coupled vars.
#' @param mother.posfix posfix identifying mother variables
#' @param daughter.posfix posfix identifying daughter variables
#' @return a restructured data.frame
#' @export
decoupleTable <- function(db, mother.posfix="_mother",daughter.posfix="_daughter"){
	mdb <- melt(db,id.var="pos")
	v <- (mdb$variable <- as.character(mdb$variable))
	nchar.v <- nchar(v)
	m <- substr(v,nchar.v-nchar(mother.posfix)+1,nchar.v)==mother.posfix
	d <- substr(v,nchar.v-nchar(daughter.posfix)+1,nchar.v)==daughter.posfix

	# mdb$type <- NA
	# mdb$type[m] <- "mother"
	# mdb$type[d] <- "daughter"
	# mdb$type <- as.factor(mdb$type)

	mdb$variable[m] <- substr(v,1,nchar.v-nchar(mother.posfix))[m]
	mdb$variable[d] <- substr(v,1,nchar.v-nchar(daughter.posfix))[d]
	mdb$variable <- as.factor(mdb$variable)
	mdb$pos <- mdb$pos * 10 + m*1 + d*2
	return(cast(mdb,pos~variable))
}

#' Decouple a cell.data pair object
#' 
#' @details Restructures from a one-pos-one-pair to a one-pos-one-cell structure. 
#' @param X a cell.data object (as returned by \code{load.FRAP.pairs} to restructure
#' @param p list of options for the FRAP experiment. Usually the default \code{X$parameters} will do.
#' @param get.PB.cell boolean indicating if the photobleached cell should be returned. If FALSE the non-PB cell is returned, which can be used for imaging PB controls. 
#' @return a restructured cell.data object
#' @export
decouplePairs <- function(X, p=X$parameters, get.PB.cell=TRUE){
	if(!isTRUE(get.PB.cell)){
		levels(X$data$FRAP.on) <- rev(levels(X$data$FRAP.on))
		levels(X$data$type) <- rev(levels(X$data$type))
	}
	#df<-subset(X$data,pos==2)
	X$data<-
	ddply(X$data,.(pos),function(df){
		ped <- makePairEXPDATA(df,p=p)
		df <- df[,setdiff(names(df),c("f.nuc.d","f.nuc.m","f.cyt.d","f.cyt.m","FRAP.on"))]

		df.m <- subset(df,type=="mother")	
		df.m <- cbind(df.m
			,rename(as.data.frame(ped$mother$y),c("V1"="f.nuc","V2"="f.cyt"))
			,rename(as.data.frame(ped$mother$std),c("V1"="sd.f.nuc","V2"="sd.f.cyt")))
		df.m <- transform(df.m, old.pos = pos, old.t.frame = t.frame)
		df.m <- transform(df.m, pos = 10*pos+1, t.frame = t.frame - min(t.frame) + 1
											  , FRAP = FRAP - min(FRAP) + 1
											  , time = time - min(time))

		df.d <- subset(df,type=="daughter")	
		df.d <- cbind(df.d
			,rename(as.data.frame(ped$daughter$y),c("V1"="f.nuc","V2"="f.cyt"))
			,rename(as.data.frame(ped$daughter$std),c("V1"="sd.f.nuc","V2"="sd.f.cyt")))
		df.d <- transform(df.d, old.pos = pos, old.t.frame = t.frame)
		df.d <- transform(df.d, pos = 10*pos+2, t.frame = t.frame - min(t.frame) + 1
											  , FRAP = FRAP - min(FRAP) + 1
											  , time = time - min(time))

		return(rbind(df.m,df.d))
	})

	#restructuring images
	X$images<-rename(X$images,c("pos"="old.pos","t.frame"="old.t.frame"))
	X$images<-join(X$images,X$data[,c("old.pos","old.t.frame","pos","t.frame")],by=c("old.pos","old.t.frame"))

	#restructuring desc.db
	X$desc.db <- rename(X$desc.db,c("pos"="old.pos"))
	X$desc.db <- join(aggregateBy(X$data,.(pos),select=c("type","old.pos"),FUN=unique),X$desc.db,by="old.pos")

	X$data$ucid <- 1e6 * X$data$pos + X$data$cellID
	X$data <- rename(X$data, c("type"="old.type"))
	X$variables$fluor <- c("f.nuc","f.cyt","sd.f.nuc","sd.f.cyt")
	X$variables$desc <- c("FRAP")
	X$variables$all <- names(X$data)

	return(X)
}

#' Restructures a cell.data object
#' 
#' @details Restructures from a one-pos-one-cell to a one-pos-one-pair structure. A 'pair' column is required in the description file (p$desc).
#' @param X a cell.data object (as returned by \code{load.FRAP.pairs} to restructure
#' @param p list of options for the FRAP experiment. Usually the default \code{X$parameters} will do.
#' @return a restructured cell.data object
#' @export
restructurePairs <- function(X,p=X$parameters){

	#restructuring data
	if("pairs"%in%names(X$data) & (!"pair"%in%names(X$data))) X$data<-rename(X$data,c("pairs"="pair"))
	if(!"pair"%in%names(X$data)) stop("pair variable required in data for restructuring")
	
	X$data<-rename(X$data,c("pos"="old.pos","t.frame"="old.t.frame"))

	#df<-subset(X$data,pair==1)
	X$data<-
	ddply(X$data,.(pair),function(df){
		if(length(unique(df$old.pos))!=2) 
			stop("exactly two pos per pair required for restructure. Found ",toString(unique(df$old.pos)))

		pos1<-min(df$old.pos)
		pos2<-max(df$old.pos)
		df$FRAP[df$old.pos==pos2] <- df$FRAP[df$old.pos==pos2] + max(df$FRAP[df$old.pos==pos1])
		#df$PBindex[df$old.pos==pos2] <- df$PBindex[df$old.pos==pos2] + max(df$FRAP[df$old.pos==pos1])
		df$t.frame[df$old.pos==pos1] <- df$old.t.frame[df$old.pos==pos1]
		df$t.frame[df$old.pos==pos2] <- df$old.t.frame[df$old.pos==pos2] + max(df$old.t.frame[df$old.pos==pos1])
		df$pos <- df$pair

		first <- unique(df$pb[df$old.pos==pos1]) 
		second <- unique(df$pb[df$old.pos==pos2])
		df$pb <- factor(paste0(first,"-",second))
		return(df)
	})

	#restructuring images
	X$images<-rename(X$images,c("pos"="old.pos","t.frame"="old.t.frame"))
	X$images<-join(X$images,X$data[,c("old.pos","old.t.frame","pos","t.frame")],by=c("old.pos","old.t.frame"))

	#restructuring desc.db
	if("pairs"%in%names(X$desc.db) & (!"pair"%in%names(X$desc.db))) X$desc.db<-rename(X$desc.db,c("pairs"="pair"))
	if(!"pair"%in%names(X$desc.db)) stop("pair variable required in desc.db for restructuring")

	#df<-subset(X$desc.db,pair==1)
	X$desc.db<-
	rename(ddply(X$desc.db,.(pair),function(df){
		df1<-colwise(unique)(df[,setdiff(names(df),c("pos","pb","pair"))])
		df1$pb<-factor(paste0(df$pb,collapse="-"))
		return(df1)
	}),c("pair"="pos"))

	X$data$ucid <- 1e6 * X$data$pos + X$data$cellID

	return(X)
}

#' Creates cell.data object from a FRAP experiment. Each pos is a single cell. 
#'
#' @param path path to the directory where the FRAP processed data is located
#' @param img.path alternative path where the original images might be
#' @param exp.name name of the experiment. By dafult the path basename
#' @param p list of options for the FRAP experiment. See \code{param.FRAP.pairs}
#' @param oifType single char indicating the 7th character of the file name used to extract the OIF time. Used to parse OIF-date.txt. 
#'				  Ignored if NULL. Use NULL if there is a single movie per pos. Use "f" if there are several fraps in tandem. 
#' @param dataVars character vector with names of variables in time-series files. 
#'				   If NA, and files have 4 coulmns c("Average","Err","f.nuc","f.cyt") is used for single cell experiment
#'				   If NA, and files have 6 coulmns c("Average","Err","f.nuc.d","f.cyt.d","f.nuc.m","f.cyt.m") is used for cell pairs experiments.
#' @param removeFirstRow boolean indicating if the first row of each file should be deleted (usually comes from the reference image)
#' @param ... elements of p to be replaced by updated value
#' @return a \code{cell.data} object, as returned by the load functiond of \code{rcell2} package
#' @export
loadFrapData<-function(path=getwd(),img.path=path,exp.name=basename(path),p=param.FRAP.pairs,oifType="f",dataVars=NA,removeFirstRow=TRUE,...){

	#replacing p elements by dots arguments of same name
  	arguments <- as.list(match.call()[-1])
	unk.args <- setdiff(names(arguments),c(names(p),"path","img.path","exp.name","p","oifType","dataVars","removeFirstRow"))
	if(length(unk.args)>0) stop("unknown parameter ",toString(unk.args))
	for(i in intersect(names(arguments),names(p))) p[[i]] <- arguments[[i]]
	
	#Searching for files
	jpg.fnames <- dir(pattern=glob2rx(p$ref.img), path=path)
	dat.fnames <- dir(pattern=glob2rx(p$time.series), path=path)
	tif.fnames <- dir(pattern=glob2rx(p$fname), path=path)
	desc.fnames <- dir(pattern=glob2rx(p$desc), path=path)
	date.fnames <- dir(pattern=glob2rx(p$OIF.date), path=path)
		
	if(length(tif.fnames)==0) message("No tif filename file of the form ",p$fname," found.\n Images won't be available. Assuming only one FRAP.")

	#description of each yeast
	#cols: lev, cepa, citokinesis, pb, fname.ab
	desc.db <- NULL
	if(length(desc.fnames)==1){
		desc.db <- read.table(paste0(path,"/",desc.fnames),head=T,as.is=TRUE)
		desc.db <- rename(desc.db,c("lev"="pos"))

		#identifying experimentally determined parameters in desc.db
		cellParamIndex <- which(names(desc.db) %in% p$MODEL.PARAMETERS)
		motherParamIndex <- which(names(desc.db) %in% paste0(p$MODEL.PARAMETERS,"_mother"))
		daughterParamIndex <- which(names(desc.db) %in% paste0(p$MODEL.PARAMETERS,"_daughter"))
		if(length(cellParamIndex) > 0 & length(motherParamIndex) > 0 ) 
			stop("all experimental parameters in levData.txt should be given for cell or mother/daughter, consistently")
		if(length(daughterParamIndex)!= length(motherParamIndex)) 
			stop("there should be equal amount of mother and daughter parameters in levData.txt")
		
		if(length(cellParamIndex) > 0){
			p$EXPERIMENTAL.PARAMETERS.DB <- desc.db[,c(which(names(desc.db) %in% "pos"),cellParamIndex)]
		} else if(length(motherParamIndex) > 0){
			p$EXPERIMENTAL.PARAMETERS.DB <- desc.db[,c(which(names(desc.db) %in% "pos"),motherParamIndex,daughterParamIndex)]
		} else {
			p$EXPERIMENTAL.PARAMETERS.DB <- NULL 
		}
	}

	#checking that ref.img, time.series and fname are ok
	dat.pos<-getNumber(dat.fnames)
	tif.pos<-getNumber(tif.fnames)
	jpg.pos<-getNumber(jpg.fnames)

	#reordeing vectors
	dat.fnames <- dat.fnames[order(dat.pos)]
	dat.pos <- dat.pos[order(dat.pos)]
	tif.fnames <- tif.fnames[order(tif.pos)]
	tif.pos <- tif.pos[order(tif.pos)]
	jpg.fnames <- jpg.fnames[order(jpg.pos)]
	jpg.pos <- jpg.pos[order(jpg.pos)]

	if(!all(tif.pos%in%dat.pos))
		stop("different number of ",p$time.series," and ",p$fname," files.\n ") 

	if(!all(jpg.pos%in%dat.pos))
		stop("different number of ",p$time.series," and ",p$ref.img," files.\n ") 
		
	#cargo tiempos de los diferentes oif
	oif.db <- NULL
	if(length(date.fnames)==1){
		if(!file.exists(paste0(path,"/",date.fnames))) stop("No ",p$OIF.date," file found \n")
		oif <- read.table(paste0(path,"/",date.fnames), sep="\t",as.is=T)
		oif.s <- seq(1,dim(oif)[1]-2,3)
		oif.db <- data.frame(
			pos=as.numeric(substring(oif[oif.s,],4,5))
			,type= substring(oif[oif.s,],7,7)
			,FRAP= suppressWarnings(as.numeric(substring(oif[oif.s,],8,8)))
			,oif.hour=chron(times=substring(oif[oif.s+1,],32,40),format=c("h:m:s"))
			,oif.msec=as.numeric(substring(oif[oif.s+2,],30,nchar(oif[oif.s+2,])))
			)
		if(!is.null(oifType)){
			if(all(is.na(oif.db$FRAP))) warning("All FRAP index value are NAs. Try using oifType=NULL")
			oif.db <- oif.db[oif.db$type==oifType,]
			if(oifType=="f") oif.db <- oif.db[!is.na(oif.db$FRAP),]
		} else {
			oif.db$FRAP <- 1
		}
		oif.db <- transformBy(oif.db,.(pos),D.oif.hour=oif.hour - oif.hour[FRAP==min(FRAP)]
										   ,D.oif.msec=oif.msec - oif.msec[FRAP==min(FRAP)])
		oif.db <- transform(oif.db
			,oif.time=3600*hours(D.oif.hour)+60*minutes(D.oif.hour)+seconds(D.oif.hour)+D.oif.msec/1000)
	} else if(length(date.fnames)==0) {
		message(p$OIF.date," not found, calculating time as t.index * SEC.PER.FRAME")
	}
		
	data<-data.frame()
	images<-data.frame()

	for(i in seq_along(dat.fnames)){
		cat("loading yeast",dat.pos[i],"...")

		dat <- read.table(paste0(path,"/",dat.fnames[i]),head=TRUE)
		if(is.na(dataVars[1])){
			if(ncol(dat)==4){
				names(dat) <- c("Average","Err","f.nuc","f.cyt")	
			} else if (ncol(dat)==6){
				names(dat) <- c("Average","Err","f.nuc.d","f.cyt.d","f.nuc.m","f.cyt.m")	
			} else {
				stop(dat.fnames[i]," should have 4 or 6 columns (for single cells or cell pairs respectively).\nUse dataVars argument otherwise.")
			}
		} else {
			if(ncol(dat)!=length(dataVars)) stop("dataVars argument of incorrect length.")
			names(dat)<-dataVars
		}

		dat$t.frame<-0:(dim(dat)[1]-1) #agrego indice
		if(removeFirstRow) dat <- dat[dat$t.frame>0,] #removing first frame (reference)
		dat$pos <- dat.pos[i]
	
		#cargo nombres de los archivos tif
		if(!is.na(tif.fnames[i])){
			tif<-read.table(paste0(path,"/",tif.fnames[i]),head=F,as.is=TRUE)
			if( dim(tif)[1] != dim(dat)[1]){
				if((dim(tif)[1]-1) == (dim(dat)[1])){
					tif<-as.data.frame(tif[2:(dim(tif)[1]),])
					message("removing first line of tif-fname.txt for pos",dat.pos[i])
				} else {
					stop("different number of registers for pos",dat.pos[i],"-time-trace.xls and tif-fname.txt\n")
				}
			}
			dat$FRAP <- getNumber(tif[[1]],after="f")
			if(all(is.na(dat$FRAP))) dat$FRAP <- 1
			dat$t.index <- getNumber(tif[[1]],after="T")
			img <- data.frame(pos=dat$pos,t.frame=dat$t.frame,channel=p$channel.name,image=tif[[1]],is.out=FALSE,stringsAsFactors=FALSE)
			img <- rbind(img,data.frame(pos=dat$pos,t.frame=dat$t.frame,channel="ref",image=jpg.fnames[i],is.out=TRUE,stringsAsFactors=FALSE))
		} else { #if no tif filename file available
			dat$FRAP <- 1
			dat$t.index <- seq_along(dat$pos)			
			img <- data.frame()
		}
		dat$cellID <- 1

		#Genero la variable time, en base a oif.db
		if(is.null(oif.db)){
			dat <- transform(dat,time=(t.index-1) * p$SEC.PER.FRAME)
		} else {
			dat <- join(dat,subset(oif.db,select=c(pos,FRAP,oif.time)),by=c("pos","FRAP"))
			dat <- transform(dat,time=(t.index-1) * p$SEC.PER.FRAME + oif.time)
		}
			
		data<-rbind(data,dat)
		images<-rbind(images,img)
		cat(" done\n")
	}	

	data <- data[,setdiff(names(data),c("Average","Err"))]
	data <- transform(data,ucid=1e6*pos+cellID,QC=TRUE,xpos=1,ypos=1,experiment=factor(exp.name))
	if(!is.null(desc.db))
		data <- join(data,desc.db,by="pos")

	if(ncol(images)>0){
		fpath.db <- suppressWarnings(get.file.path(images$image,path,img.path))
		images$path<-factor(fpath.db$path)
		if(any(fpath.db$found)) message("Images found at ",toString(unique(fpath.db$path)))
		if(any(!fpath.db$found)) message("Some or all images not found. Use the 'input.path' argument or update_img.path \n")

		images$path<-factor(images$path)
		images$channel<-factor(images$channel)
	}

	variables <- list(id.vars=c("experiment","pos","cellID","t.frame")
				,id.vars.deriv=c("pos","cellID","ucid","t.frame","t.index")
				,morpho=c("xpos","ypos")
				,as.factor=c("pos")
				,fluor=grep(glob2rx("f.*"),names(data),value=T)
				,QC="QC"
				,desc=intersect(c("FRAP","FRAP.on","type"),names(data)))
	variables$all<-names(data)

	#creating cell data object
	cell.data<-
		list(data=data
			,QC.history=list()
			,subset.history=list()
			,transform=list()
			,channels=data.frame(postfix=c(""),name=c(""))
			,variables=variables
			,images=images
			,desc.db=desc.db
			,software="Nuclear FRAP"
			,load.date=date()
			,load.sessionInfo=sessionInfo()
			,experiment=exp.name
			,parameters=p
        )
	class(cell.data)<-c("cell.data","list")
	print(summary(cell.data))
	return(cell.data)
}


#' Creates cell.data object from FRAP experiment. Each pos can be a cell or cell pair. 
#'
#' @param path path to the directory where the FRAP processed data is located
#' @param img.path alternative path where the original images might be
#' @param exp.name name of the experiment. By dafult the path basename
#' @param p list of options for the FRAP experiment. See \code{param.FRAP.pairs}
#' @param ... elements of p to be replaced by updated value
#' @return a \code{cell.data} object, as returned by the load functiond of \code{rcell2} package
#' @export
loadFrapPairs<-function(path=getwd(),img.path=path,exp.name=basename(path),p=param.FRAP.pairs,...){

	cell.data <- loadFrapData(path=path,img.path=img.path,exp.name=exp.name,p=p,...)
	if(!"desc.db"%in%names(cell.data)) stop("Description table required for cell pair experiments")

	###############Data Manipulation #########################
	#dat<-subset(cell.data$data,pos==1)
	cell.data$data<-ddply(cell.data$data,.(pos),function(dat){
		#defino que FRAP se hizo sobre que celula
		pb.str<-as.character(subset(cell.data$desc.db,pos==unique(dat$pos),select=pb))
		pb.order<-strsplit(pb.str,p$FRAP.ORDER.SEP)[[1]]
		TOTAL.FRAPS=0
		FRAP.on.db<-data.frame()
		for(j in pb.order) {
			if(j==p$FRAP.ORDER.MOTHER.STR){
				FRAP.on.db=rbind(FRAP.on.db,data.frame(
								FRAP=(TOTAL.FRAPS+1):(TOTAL.FRAPS+p$MOTHER.FRAP.NUMBER)
								,FRAP.on=p$FRAP.ORDER.MOTHER.STR))
				TOTAL.FRAPS=TOTAL.FRAPS+p$MOTHER.FRAP.NUMBER
			}else if(j==p$FRAP.ORDER.DAUGHTER.STR){
				FRAP.on.db=rbind(FRAP.on.db,data.frame(
								FRAP=(TOTAL.FRAPS+1):(TOTAL.FRAPS+p$DAUGHTER.FRAP.NUMBER)
								,FRAP.on=p$FRAP.ORDER.DAUGHTER.STR))
				TOTAL.FRAPS=TOTAL.FRAPS+p$DAUGHTER.FRAP.NUMBER
			}else stop("unknown identifier ",j,"for FRAP order in levData.txt")
		}
		#agrego columna FRAP.on a dat
		dat<-join(dat,FRAP.on.db,by="FRAP")
		#corrijo por autofluroescencia
		dat<-transform(dat	,f.nuc.d=f.nuc.d-p$AUTO.F
							,f.nuc.m=f.nuc.m-p$AUTO.F
							,f.cyt.d=f.cyt.d-p$AUTO.F
							,f.cyt.m=f.cyt.m-p$AUTO.F)
		#si algun valor de fluorescencia me dio negativo, lo mando a cero
		dat<-transform(dat	,f.nuc.d=ifelse(f.nuc.d>=0,f.nuc.d,0)
							,f.nuc.m=ifelse(f.nuc.m>=0,f.nuc.m,0)
							,f.cyt.d=ifelse(f.cyt.d>=0,f.cyt.d,0)
							,f.cyt.m=ifelse(f.cyt.m>=0,f.cyt.m,0))
		#corrijo por photobleaching
		dat<-transform(dat	,f.nuc.d=p$PB.CORRECTION.FUN(f.nuc.d,time)
							,f.nuc.m=p$PB.CORRECTION.FUN(f.nuc.m,time)
							,f.cyt.d=p$PB.CORRECTION.FUN(f.cyt.d,time)
							,f.cyt.m=p$PB.CORRECTION.FUN(f.cyt.m,time))
		#corrijo por factor de correcion citoplasmatico
		dat<-transform(dat	,f.cyt.d=f.cyt.d*p$F.COR.CYT
							,f.cyt.m=f.cyt.m*p$F.COR.CYT)
		return(dat)
	})	

	cell.data$data<-join(cell.data$data
		,data.frame(FRAP.on=c(p$FRAP.ORDER.DAUGHTER.STR,p$FRAP.ORDER.MOTHER.STR),type=c("daughter","mother"))
		,by="FRAP.on")

	cell.data$variables$desc <- c("FRAP","FRAP.on","type")
	cell.data$variables$all <- names(cell.data$data)
	cell.data$channels <- data.frame(postfix=c("d","m"),name=c("daughter","mother"))
	cell.data$software <- "Nuclear FRAP pairs"

	return(cell.data)
}

#' Gets the number on a string
#'
#' @param fname string from which to extract numbers
#' @param after string pattern after which the required number is located
#' @return a numeric vector, extracted from \code{fname}
#' @export
getNumber<-function(fname,after=""){
	rx<-regexpr(paste0(after,"[0-9]+"),fname)
	as.numeric(substring(fname,rx+nchar(after),rx+attr(rx,"match.length")-1))
}

#' The colors used by dafualt by gglot2 for factors
#'
#' @param n number of colors to return
#' @return string description of colors
#' @export
#' @examples
#' gg_color_hue(4)
gg_color_hue <- function(n) {
  hues = seq(15, 375, length=n+1)
  hcl(h=hues, l=65, c=100)[1:n]
}

makeSeq<-function(x,nGrid=20) seq(x[1]-0.5*abs(x[2]-x[1]),x[2]+0.5*abs(x[2]-x[1]),length.out=nGrid)

#*************************************************************************#
#private
#finds a the path to a file from a vector of candidates paths
get.file.path<-function(filename,path,alternative.path=getwd()){

	df<-data.frame(name=as.character(filename),path=normalizePath(as.character(path),winslash="/",mustWork=FALSE),found=FALSE,stringsAsFactors=FALSE)
	if(anyDuplicated(filename)!=0) warning("duplicated filenames")
	df$found <- df$found | file.exists(normalizePath(paste(df$path,df$name,sep="/"),winslash="/",mustWork=FALSE))
	df$path[!df$found] <- NA

	i<-1
	while(!all(df$found)&i<=length(alternative.path)){
		found.v <- file.exists(normalizePath(paste(alternative.path[i],df$name,sep="/"),winslash="/",mustWork=FALSE))
		if(any(found.v)) df$path[found.v&!df$found] <- alternative.path[i]
		df$found <- df$found | found.v
		i <- i + 1
	}

	return(df)
}
